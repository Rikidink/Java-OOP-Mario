CL_Lab1Team6
Marked based on commit 1025f65ae4b58845785137a5764bf2e0a9813b4e

Q1: Use of git and gitlab
Multiple commits are created, and the commit messages are helpful. Well done!

Q2: Presentation (including UML syntax)
All diagrams appear complete and readable, and UML standards (syntax) have been followed where applicable: inheritance/implementation/association arrowheads are correct. Minor error in the UML class diagram for requirement 7: it should be <<interface>> not <<interfact>> for Resettable.
Feedback for the sequence diagrams:
The arrows representing synchronous message sending should have a solid, coloured arrowhead, i.e. ▶ instead of >. (no penalty applied due to syntax errors in the sequence diagram example given for the implementation of the AttackAction.execute method)

Q3: Design quality
Q3.1: Completeness (requirements coverage)
Some enemy behaviours are missing from the UML class diagram for requirement 3. Note that WanderBehaviour and FollowBehaviour are important for the Enemy class and they should be included in the design of the enemy requirement.

Q3.2 Ease of comprehension (clarity of design rationale text and diagrams)
There are some inconsistencies between the design rationale and the UML class diagram. For instance, the association relationship between ResetManager and the Resettable interface has 1 1 multiplicities. However, the design rationale mentions that the Resettable will be stored in a List data structure, implying that there can be multiple resettables managed by ResetManager. Therefore, the multiplicities should be 0..* on the Resettable side.

Q3.3 Good design (following design principles)
Note that, for requirement 2, not all grounds are jumpable. “a method within the JumpAction class can determine the type of Ground object at the
Location” may imply the usage of instanceof, which is an indicator of bad design. Therefore, it is recommended to create an abstract parent class that can be extended by both Wall and Tree, such as a HighGround class. The JumpAction class will then have an association relationship with this HighGround class, i.e. it stores a HighGround object as an attribute since each HighGround has unique fall damage and success rate. For example, Sprout has a 90% success rate and 10 fall damage, while Mature has a 70% success rate and 30 fall damage.
Furthermore, why a HighGround class? Note that requirement 4 states that if an actor that has a power star “steps on high ground, it will automatically destroy (convert) [the high ground] to Dirt“, which implies that Tree and Wall share similar behaviour. Therefore, it is recommended for Tree and Wall to inherit from an abstract HighGround class to avoid code repetition (DRY principle). 
Based on how the engine code works, the Player does not need to know the JumpAction instance, i.e. no dependency between JumpAction and Player. The JumpAction instance will be generated by the allowableActions method of the HighGround class, not by the Player class.
Next, in the UML class diagram for requirement 3, Goomba and Koopa both have an association relationship with the Behaviour interface, which implies code repetition as they both have an attribute that stores a list of Behaviours. What you should do instead is to create an Enemy abstract class to handle the similar behaviour between Goomba and Koopa, such as iterating through the list of behaviours to find the one that can return a valid action to be performed on a particular turn. This pattern is similar to the Tree abstract class that you proposed for requirement 1.
Note that not all items can be consumed by the Player. The association relationship between ConsumeItemAction and the Item abstract class violates this pre-condition, i.e. not all items are consumable (see design by contract). Instead of having an association relationship between Item and ConsumeItemAction, you should have an association relationship between ConsumeItemAction and the Consumable interface. If there is a new consumable added in the future, it can simply implement the Consumable interface. Since ConsumeItemAction knows about this Consumable interface, it does not need to be changed as it simply needs to call the existing method provided by the interface. Therefore, the open-closed principle will not be violated. Furthermore, based on how the engine code works, the ConsumeItemAction does not need to store an Actor as its attribute. This is because, if you look at the execute method of the Action class, an instance of the Actor class will be passed in as an input. This Actor is the one that is performing the action, i.e. the consumer of the consumable.
Implementing wallet as an attribute of the Player class violates the Single Responsibility Principle. This is because the Player is now responsible for managing their own play turn and state as well as managing the wallet balance, such as adding and deducting balance. It is recommended that a Wallet class be created in the system.
Here, BuyAction does not need to know about Actor. Instead, based on how the game engine works, it is Toad that should create an instance of BuyAction in their allowableActions method. The BuyAction should know which item is being purchased by the Player. Therefore, there should be an association relationship between BuyAction and the Sellable interface.

Q3.4 Design is well-justified (quality of design rationale)
Although the design rationale mentioned that the Tree class is implemented as an abstract class, the UML class diagram shows the Tree class implemented as a concrete class. It does not have the <<abstract>> stereotype nor it is written in italics.
“If a new subclass of Ground that can be jumped to is added to the game, only the JumpAction class will be modified to accommodate this change“ is still a violation of the Open-closed principle. As suggested above, by adding a HighGround parent class and creating an association relationship between the HighGround abstract class and the JumpAction class, you do not need to modify any of the existing classes. This is because the JumpAction class only needs to know the abstract HighGround parent class. As long as the newly added jumpable ground implements all of the expected methods of a HighGround, then JumpAction would work just find with the new type of jumpable ground.
As specified in the feedback for Q3.3, the Enemy abstract class would help you in achieving the DRY principle, e.g. if a new enemy is added in the future, it can simply extend the abstract Enemy class, and it will inherit functionalities shared by all enemies, such as which action to perform in a particular turn. If you need to add customised functionality to the new enemy, you can override the existing method of the Enemy abstract class without modifying it. Therefore, the Open-closed principle will not be violated.

Interview
The interview questions are answered really well.
